@article{reps_ilps_1997,
title = {Program analysis via graph reachability1An abbreviated version of this paper appeared as an invited paper in the Proceedings of the 1997 International Symposium on Logic Programming [84].1},
journal = {Information and Software Technology},
volume = {40},
number = {11},
pages = {701-726},
year = {1998},
issn = {0950-5849},
doi = {https://doi.org/10.1016/S0950-5849(98)00093-7},
url = {https://www.sciencedirect.com/science/article/pii/S0950584998000937},
author = {Thomas Reps},
abstract = {This paper describes how a number of program-analysis problems can be solved by transforming them to graph-reachability problems. Some of the program-analysis problems that are amenable to this treatment include program slicing, certain dataflow-analysis problems, one version of the problem of approximating the possible “shapes” that heap-allocated structures in a program can take on, and flow-insensitive points-to analysis. Relationships between graph reachability and other approaches to program analysis are described. Some techniques that go beyond pure graph reachability are also discussed.}
}

@article{ding_sas_2023,
title = {Mutual Refinements of Context-Free Language Reachability}, 
url = {https://par.nsf.gov/biblio/10507107}, 
abstract = {Context-free language reachability is an important program analysis framework, but the exact analysis problems can be intractable or undecidable, where CFL-reachability approximates such problems. For the same problem, there could be many over-approximations based on different CFLs C1,…,Cn. Suppose the reachability result of each Ci produces a set Pi of reachable vertex pairs. Is it possible to achieve better precision than the straightforward intersection ⋂ni=1Pi? This paper gives an affirmative answer: although CFLs are not closed under intersections, in CFL-reachability we can “intersect” graphs. Specifically, we propose mutual refinement to combine different CFL-reachability-based over-approximations. Our key insight is that the standard CFL-reachability algorithm can be slightly modified to trace the edges that contribute to the reachability results of C1, and C2-reachability only need to consider contributing edges of C1, which can, in turn, trace the edges that contribute to C2-reachability, etc. We prove that there exists a unique optimal refinement result (fix-point). Experimental results show that mutual refinement can achieve better precision than the straightforward intersection with reasonable extra cost.}, journal = {International Static Analysis Symposium}, 
volume = {14284}, 
publisher = {Springer}, 
author = {Shuo, Ding and Zhang, Qirun}, 
editor = {Hermenegildo, Manuel and Morales, José} }

@article{lei_pldi_2023,
author = {Lei, Yuxiang and Sui, Yulei and Tan, Shin Hwei and Zhang, Qirun},
title = {Recursive State Machine Guided Graph Folding for Context-Free Language Reachability},
year = {2023},
issue_date = {June 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {PLDI},
url = {https://doi.org/10.1145/3591233},
doi = {10.1145/3591233},
abstract = {Context-free language reachability (CFL-reachability) is a fundamental framework for program analysis. A large variety of static analyses can be formulated as CFL-reachability problems, which determines whether specific source-sink pairs in an edge-labeled graph are connected by a reachable path, i.e., a path whose edge labels form a string accepted by the given CFL. Computing CFL-reachability is expensive. The fastest algorithm exhibits a slightly subcubic time complexity with respect to the input graph size. Improving the scalability of CFL-reachability is of practical interest, but reducing the time complexity is inherently difficult.    In this paper, we focus on improving the scalability of CFL-reachability from a more practical perspective---reducing the input graph size. Our idea arises from the existence of trivial edges, i.e., edges that do not affect any reachable path in CFL-reachability. We observe that two nodes joined by trivial edges can be folded---by merging the two nodes with all the edges joining them removed---without affecting the CFL-reachability result. By studying the characteristic of the recursive state machines (RSMs), an alternative form of CFLs, we propose an approach to identify foldable node pairs without the need to verify the underlying reachable paths (which is equivalent to solving the CFL-reachability problem). In particular, given a CFL-reachability problem instance with an input graph G and an RSM, based on the correspondence between paths in G and state transitions in RSM, we propose a graph folding principle, which can determine whether two adjacent nodes are foldable by examining only their incoming and outgoing edges.    On top of the graph folding principle, we propose an efficient graph folding algorithm GF. The time complexity of GF is linear with respect to the number of nodes in the input graph. Our evaluations on two clients (alias analysis and value-flow analysis) show that GF significantly accelerates RSM/CFL-reachability by reducing the input graph size. On average, for value-flow analysis, GF reduces 60.96\% of nodes and 42.67\% of edges of the input graphs, obtaining a speedup of 4.65\texttimes{} and a memory usage reduction of 57.35\%. For alias analysis, GF reduces 38.93\% of nodes and 35.61\% of edges of the input graphs, obtaining a speedup of 3.21\texttimes{} and a memory usage reduction of 65.19\%.},
journal = {Proc. ACM Program. Lang.},
month = jun,
articleno = {119},
numpages = {25},
keywords = {CFL-reachability, graph simplification, recursive state machines}
}


@inproceedings{alur_stoc_2004,
author = {Alur, Rajeev and Madhusudan, P.},
title = {Visibly pushdown languages},
year = {2004},
isbn = {1581138520},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1007352.1007390},
doi = {10.1145/1007352.1007390},
abstract = {We propose the class of visibly pushdown languages as embeddings of context-free languages that is rich enough to model program analysis questions and yet is tractable and robust like the class of regular languages. In our definition, the input symbol determines when the pushdown automaton can push or pop, and thus the stack depth at every position. We show that the resulting class Vpl of languages is closed under union, intersection, complementation, renaming, concatenation, and Kleene-*, and problems such as inclusion that are undecidable for context-free languages are Exptime-complete for visibly pushdown automata. Our framework explains, unifies, and generalizes many of the decision procedures in the program analysis literature, and allows algorithmic verification of recursive programs with respect to many context-free properties including access control properties via stack inspection and correctness of procedures with respect to pre and post conditions. We demonstrate that the class Vpl is robust by giving two alternative characterizations: a logical characterization using the monadic second order (MSO) theory over words augmented with a binary matching predicate, and a correspondence to regular tree languages. We also consider visibly pushdown languages of infinite words and show that the closure properties, MSO-characterization and the characterization in terms of regular trees carry over. The main difference with respect to the case of finite words turns out to be determinizability: nondeterministic B\"{u}chi visibly pushdown automata are strictly more expressive than deterministic Muller visibly pushdown automata.},
booktitle = {Proceedings of the Thirty-Sixth Annual ACM Symposium on Theory of Computing},
pages = {202–211},
numpages = {10},
keywords = {verification, regular tree languages, pushdown automata, logic, context-free languages, ω-languages},
location = {Chicago, IL, USA},
series = {STOC '04}
}

@article{alur_toplas_2005,
author = {Alur, Rajeev and Benedikt, Michael and Etessami, Kousha and Godefroid, Patrice and Reps, Thomas and Yannakakis, Mihalis},
title = {Analysis of recursive state machines},
year = {2005},
issue_date = {July 2005},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {27},
number = {4},
issn = {0164-0925},
url = {https://doi.org/10.1145/1075382.1075387},
doi = {10.1145/1075382.1075387},
abstract = {Recursive state machines (RSMs) enhance the power of ordinary state machines by allowing vertices to correspond either to ordinary states or to potentially recursive invocations of other state machines. RSMs can model the control flow in sequential imperative programs containing recursive procedure calls. They can be viewed as a visual notation extending Statecharts-like hierarchical state machines, where concurrency is disallowed but recursion is allowed. They are also related to various models of pushdown systems studied in the verification and program analysis communities.After introducing RSMs and comparing their expressiveness with other models, we focus on whether verification can be efficiently performed for RSMs. Our first goal is to examine the verification of linear time properties of RSMs. We begin this study by dealing with two key components for algorithmic analysis and model checking, namely, reachability (Is a target state reachable from initial states?) and cycle detection (Is there a reachable cycle containing an accepting state?). We show that both these problems can be solved in time O(nθ2) and space O(nθ), where n is the size of the recursive machine and θ is the maximum, over all component state machines, of the minimum of the number of entries and the number of exits of each component. From this, we easily derive algorithms for linear time temporal logic model checking with the same complexity in the model. We then turn to properties in the branching time logic CTL*, and again demonstrate a bound linear in the size of the state machine, but only for the case of RSMs with a single exit node.},
journal = {ACM Trans. Program. Lang. Syst.},
month = jul,
pages = {786–818},
numpages = {33},
keywords = {temporal logic, recursive state machines, pushdown automata, program analysis, model checking, context-free languages, Software verification}
}

@INPROCEEDINGS{heintze_lics_1997,
  author={Heintze, N. and McAllester, D.},
  booktitle={Proceedings of Twelfth Annual IEEE Symposium on Logic in Computer Science}, 
  title={On the cubic bottleneck in subtyping and flow analysis}, 
  year={1997},
  volume={},
  number={},
  pages={342-351},
  keywords={Algorithm design and analysis;Automatic control;Automata},
  doi={10.1109/LICS.1997.614960}}

@inproceedings{zhang_pldi_2013,
author = {Zhang, Qirun and Lyu, Michael R. and Yuan, Hao and Su, Zhendong},
title = {Fast algorithms for Dyck-CFL-reachability with applications to alias analysis},
year = {2013},
isbn = {9781450320146},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2491956.2462159},
doi = {10.1145/2491956.2462159},
abstract = {The context-free language (CFL) reachability problem is a well-known fundamental formulation in program analysis. In practice, many program analyses, especially pointer analyses, adopt a restricted version of CFL-reachability, Dyck-CFL-reachability, and compute on edge-labeled bidirected graphs. Solving the all-pairs Dyck-CFL-reachability on such bidirected graphs is expensive. For a bidirected graph with n nodes and m edges, the traditional dynamic programming style algorithm exhibits a subcubic time complexity for the Dyck language with k kinds of parentheses. When the underlying graphs are restricted to bidirected trees, an algorithm with O(n log n log k) time complexity was proposed recently. This paper studies the Dyck-CFL-reachability problems on bidirected trees and graphs. In particular, it presents two fast algorithms with O(n) and O(n + m log m) time complexities on trees and graphs respectively. We have implemented and evaluated our algorithms on a state-of-the-art alias analysis for Java. Results on standard benchmarks show that our algorithms achieve orders of magnitude speedup and consume less memory.},
booktitle = {Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {435–446},
numpages = {12},
keywords = {alias analysis, dyck-cfl-reachability},
location = {Seattle, Washington, USA},
series = {PLDI '13}
}

@inproceedings{kodumal_pldi_2004,
author = {Kodumal, John and Aiken, Alex},
title = {The set constraint/CFL reachability connection in practice},
year = {2004},
isbn = {1581138075},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/996841.996867},
doi = {10.1145/996841.996867},
abstract = {Many program analyses can be reduced to graph reachability problems involving a limited form of context-free language reachability called Dyck-CFL reachability. We show a new reduction from Dyck-CFL reachability to set constraints that can be used in practice to solve these problems. Our reduction is much simpler than the general reduction from context-free language reachability to set constraints. We have implemented our reduction on top of a set constraints toolkit and tested its performance on a substantial polymorphic flow analysis application.},
booktitle = {Proceedings of the ACM SIGPLAN 2004 Conference on Programming Language Design and Implementation},
pages = {207–218},
numpages = {12},
keywords = {context-free language reachability, flow analysis, set constraints, type qualifiers},
location = {Washington DC, USA},
series = {PLDI '04}
}

@article{lei_pldi_2024,
author = {Lei, Yuxiang and Bossut, Camille and Sui, Yulei and Zhang, Qirun},
title = {Context-Free Language Reachability via Skewed Tabulation},
year = {2024},
issue_date = {June 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {PLDI},
url = {https://doi.org/10.1145/3656451},
doi = {10.1145/3656451},
abstract = {Context-free language reachability (CFL-reachability) is a prominent model for formulating program analysis problems. Almost all CFL-reachability algorithms are based on the Reps-Horwitz-Sagiv (RHS) tabulation. In essence, the RHS tabulation, based on normalized context-free grammars, is similar to the CYK algorithm for CFL-parsing. Consider a normalized rule S::=A&nbsp;B and a CFL-reachability problem instance of computing S-edges in the input graph. The RHS tabulation obtains all summary edges (i.e., S-, A-, and B-edges) based on the grammar rules. However, many A- and B-edges are wasted because only a subset of those edges eventually contributes to generating S-edges in the input graph.This paper proposes a new tabulation strategy for speeding up CFL-reachability by eliminating wasted and unnecessary summary edges. We particularly focus on recursive nonterminals. Our key technical insight is that the wasted edge generations and insertions caused by recursive nonterminals can be avoided by modifying the parse trees either statically (by transforming the grammar) or dynamically (using a specialized online CFL-reachability solver). For example, if a recursive nonterminal B, generated by a rule B::=BX, appears on the right-hand side of a rule S::=AB, we can make S recursive (by introducing a new rule S::=SX) and eliminate the original recursive rule (B::=BX). Due to the rule S::=SX, the shapes of the parse trees associated with the left-hand-side nonterminal S become more “skewed”. Thus, we name our approach skewed tabulation for CFL-reachability.Skewed tabulation can significantly improve the scalability of CFL-reachability by reducing wasted and unnecessary summary edges. We have implemented skewed tabulation and applied the corresponding CFL- reachability algorithm to an alias analysis, a value-flow analysis, and a taint analysis. Our extensive evaluation based on SPEC 2017 benchmarks yields promising results. For the three client analyses, CFL-reachability based on skewed tabulation can achieve 3.34\texttimes{}, 1.13\texttimes{} and 2.05\texttimes{} speedup over the state-of-the-art RHS-tabulation- based CFL-reachability solver and consume 60.05\%, 20.38\% and 63.06\% less memory, respectively. Furthermore, the cost of grammar transformation for skewed tabulation is negligible, typically taking less than one second.},
journal = {Proc. ACM Program. Lang.},
month = jun,
articleno = {221},
numpages = {24},
keywords = {CFL-reachability, tabulation schemes, performance}
}

@article{melski_sigplan_1997,
author = {Melski, David and Reps, Thomas},
title = {Interconvertbility of set constraints and context-free language reachability},
year = {1997},
issue_date = {Dec. 1997},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {32},
number = {12},
issn = {0362-1340},
url = {https://doi.org/10.1145/258994.259006},
doi = {10.1145/258994.259006},
abstract = {We show the interconvertibility of context-free-language reachability problems and a class of set-constraint problems: given a context-free-language reachability problem, we show how to construct a set-constraint problem whose answer gives a solution to the reachability problem; given a set-constraint problem, we show how to construct a context-free-language reachability problem whose answer gives a solution to the set-constraint problem. The interconvertibility of these two formalisms offers an conceptual advantage akin to the advantage gained from the interconvertibility of finite-state automata and regular expressions in formal language theory, namely, a problem can be formulated in whichever formalism is most natural. It also offers some insight into the "O(n3) bottleneck" for different types of program-analysis problems, and allows results previously obtained for context-free-language reachability problems to be applied to set-constraint problems.},
journal = {SIGPLAN Not.},
month = dec,
pages = {74–89},
numpages = {16}
}

@article{lengauer_toplas_1979,
author = {Lengauer, Thomas and Tarjan, Robert Endre},
title = {A fast algorithm for finding dominators in a flowgraph},
year = {1979},
issue_date = {July 1979},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {1},
issn = {0164-0925},
url = {https://doi.org/10.1145/357062.357071},
doi = {10.1145/357062.357071},
abstract = {A fast algorithm for finding dominators in a flowgraph is presented. The algorithm uses  depth-first search and an efficient method of computing functions defined on paths in trees. A simple implementation of the algorithm runs in O(m log n) time, where m is the number of edges and n is the number of vertices in the problem graph. A more sophisticated implementation runs in O(mα(m, n)) time, where α(m, n) is a functional inverse of Ackermann's function.Both versions of the algorithm were implemented in Algol W, a Stanford University version of Algol, and tested on an IBM 370/168. The programs were compared with an implementation by Purdom and Moore of a straightforward O(mn)-time algorithm, and with a bit vector algorithm described by Aho and Ullman. The fast algorithm beat the straightforward algorithm and the bit vector algorithm on all but the smallest graphs tested.},
journal = {ACM Trans. Program. Lang. Syst.},
month = jan,
pages = {121–141},
numpages = {21}
}
